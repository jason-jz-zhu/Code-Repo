# dfs
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        initial = set(initial)
        t_visited = set()
        max_infected_num = -1
        del_node = min(initial)
        for i in range(len(graph)):
            if i not in t_visited:
                visited = set([i])
                self.dfs(i, graph, visited)
                infected = visited & initial
                if len(infected) == 1:
                    if len(visited) > max_infected_num or (len(visited) == max_infected_num and list(infected)[0] < del_node):
                        del_node, max_infected_num = list(infected)[0], len(visited)
            t_visited |= visited
        return del_node

    def dfs(self, node, graph, visited):
        visited.add(node)
        for j in range(len(graph[node])):
            if graph[node][j] == 1 and j not in visited:
                self.dfs(j, graph, visited)

# bfs
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        initial = set(initial)
        t_visited = set()
        max_infected_num = -1
        del_node = min(initial)
        for i in range(len(graph)):
            if i not in t_visited:
                visited = set([i])
                self.bfs(i, graph, visited)
                infected = visited & initial
                if len(infected) == 1:
                    if len(visited) > max_infected_num or (len(visited) == max_infected_num and list(infected)[0] < del_node):
                        del_node, max_infected_num = list(infected)[0], len(visited)
            t_visited |= visited
        return del_node

    def bfs(self, node, graph, visited):
        q = collections.deque([node])
        visited.add(node)
        while q:
            top = q.popleft()
            for j in range(len(graph[top])):
                if graph[top][j] == 1 and j not in visited:
                    q.append(j)
                    visited.add(j)

# union find
class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        self.father = [i for i in range(len(graph))]
        self.count = [1 for i in range(len(graph))]

        for i in range(len(graph)):
            for j in range(len(graph[i])):
                if graph[i][j] == 1 and i != j:
                    self.union(i, j)

        max_infected_num = -1
        del_node = min(initial)
        hash_count = collections.Counter(self.find(node) for node in initial)
        for node in initial:
            root_node = self.find(node)
            if hash_count[root_node] == 1:
                if self.count[root_node] > max_infected_num or (self.count[root_node] == max_infected_num and node < del_node):
                    del_node, max_infected_num = node, self.count[root_node]

        return del_node

    def find(self, node):
        if node == self.father[node]:
            return node
        self.father[node] = self.find(self.father[node])
        return self.father[node]

    def union(self, x, y):
        root_x = self.find(x)
        root_y = self.find(y)
        if root_x != root_y:
            self.father[root_x] = root_y
            self.count[root_y] += self.count[root_x]
